:mod:`metabase` --- Easy data sharing and access
=================================================

.. module:: metabase
   :synopsis: easy data sharing and access
.. moduleauthor:: Christopher Lee <leec@chem.ucla.edu>
.. sectionauthor:: Christopher Lee <leec@chem.ucla.edu>



.. class:: ResourceServer(mdb, name, serverClasses=None, clientHost=None, withIndex=False, host=None, port=5000, excludeClasses=None, downloadDB=None, **kwargs)

   Construct a new XMLRPC server to serve all worldbase resources
   currently loaded in memory that are capable of XMLRPC client-server
   operation.  

   *mdb* specifies the :class:`Metabase` or :class:`MetabaseList` whose
   resources you wish to make available online.  Typically this will just
   be ``worldbase._mdb``.

   The server *name* will be used for
   purposes of XMLRPC communication.  The *withIndex=True* option
   will cause the server to also act as a worldbase metabase
   accessible via XMLRPC (i.e. add its URL to your PYGRDATAPATH environment
   variable, to make its resources accessible to any Python script).
   In this case, the server will add itself as new worldbase layer
   *name*, for any Python script that accesses its resource index.

   Currently, newServer() can serve three types of data as remote
   XMLRPC services: :class:`NLMSA`, :class:`BlastDB`, and :class:`AnnotationDB`.

   *serverClasses* allows you to specify a list of tuples of
   classes that can be served via XMLRPC.  Each tuple should consist of
   three values: *(dbClass,clientClass,serverClass)*, where
   *dbClass* is a normal pygr class, *clientClass* is the
   class to use for the XMLRPC client version of this data, and
   *serverClass* is the class to use for the XMLRPC server of
   this data.  If no value is provided to this option, the current
   default is::

      [(seqdb.SequenceFileDB,seqdb.XMLRPCSequenceDB,seqdb.BlastDBXMLRPC),
      (seqdb.BlastDB,seqdb.XMLRPCSequenceDB,seqdb.BlastDBXMLRPC),
      (AnnotationDB,AnnotationClient,AnnotationServer),
      (cnestedlist.NLMSA,xnestedlist.NLMSAClient,xnestedlist.NLMSAServer)]

   The *clientHost* option allows you to override the hostname
   that clients will be instructed to connect to.  The default is simply
   the fully qualified hostname of your computer.  But if, for example,
   you wished to access your server by port-forwarding localhost port 5000
   to your server port via SSH, you could pass a *clientHost*='localhost'
   setting.

   *excludeClasses*, if not None, should be a list of classes that
   should be excluded from the new server.  If None, the default is
   [pygr.sqlgraph.SQLTableBase,pygr.sqlgraph.SQLGraphClustered], since
   such relational database resources are better accessed directly from
   the relational database server, rather than via the XMLRPC server as
   an intermediate step.

   *downloadDB*, if not None, should be a file path to a pygr.Data
   shelve file in which a set of downloadable resource records have been
   stored.  See the section "download=True Mode" above for more details.

   *host, port* arguments are passed to the :class:`XMLRPCServerBase` constructor.
   For details see that section below.

   Once you create a server using this method, you start it using its
   :meth:`serve_forever()` method.  If the server does not provide its
   own index (i.e. *withIndex=False*), then you should first register
   it to your local metabase server (so that clients of that server
   will know about the new services your new server is providing), by
   calling its :meth:`register()` method.



.. function:: dumps(obj)

   Provides a worldbase-aware pickling service; that is, if
   during pickling of *obj* any references are encountered
   to objects that worldbase IDs, it will simply save the ID.
   Returns a string pickle of *obj*.
   Use pygr.Data.loads() to restore an object pickled using this function.


.. function:: loads(data,cursor=None)

   Unpickles the string pickle contained in *data* in a worldbase-aware
   manner.  I.e. any references in the pickle of the form "PYGR_DATA_ID:"
   will be retrieved by worldbase in the usual way.

   *data* should have
   been generated by a previous call to pygr.Data.dumps().

   *cursor* if not None, must be a Python DB API 2.0 compliant
   cursor object, that will be used to load any objects that require
   a database connection.



pygr.Data Layers
----------------
To provide an intuitive way to refer to different metabases,
pygr.Data associates "layer names" with them.  For example, the layer
name for the first metabase whose path is given relative to
your home directory is ``my``, and the first one whose path is given
relative to current directory is ``here``.  Remote metabases
(XMLRPC; MySQL) each store their own layer name.  For example, within the
Lee lab, we keep a MySQL metabase whose layer name is "leelab".


* You can specify precisely which layer you want to access by prefixing
  your pygr.Data resource name with the desired layer name, e.g.::
  
     nlmsa = pygr.Data.leelab.Bio.MSA.UCSC.hg17_multiz17way()
  
  
* Similarly, you can specify which layer you want to store a resource
  or schema, in the same way::
  
     pygr.Data.leelab.schema.Bio.Annotation.ASAP2.hg17.splicegraph = \
       pygr.Data.ManyToManyRelation(exons,exons,splices, # ADD ITS SCHEMA RELATIONS
                                    bindAttrs=('next','previous','exons'))
  
  
* If you do not specify a layer, pygr.Data uses the first resource
  database in its list that returns the desired resource.
  
* You can delete a resource and its schema rules from a specific resource
  database by specifying its layer name::
  
     del pygr.Data.leelab.Bio.MSA.UCSC.hg17_multiz17way
  
  
* pygr.Data provides a set of default layer names:
  the first metabase whose path is given relative to
  your home directory is ``my``; the first one whose path is given
  relative to current directory is ``here``;the first one whose path is given
  relative to the root directory / is ``system``;
  the first entry that begins with a relative path
  (ie. a local file path that does not fit any of the preceding
  definitions) is ``subdir``;
  the first one whose path begins "http://" is ``remote``;
  the first one whose path begins "mysql:" is ``MySQL``.
  


worldbase Schema Concepts
-------------------------
Parallel to the worldbase namespace, worldbase maintains a schema namespace
that records schema information for worldbase resources.  Broadly speaking,
*schema* is any relationship that holds true over a set of data in a given
collection (e.g. in the human genome, "genes have exons", a one-to-many relation).
In traditional (relational) databases, this schema information is usually
represented by *entity-relationship diagrams* showing foreign-key
relationships between tables.  A worldbase resource is a collection
of objects (referred to in these docs as a "container" or "database");
thus in pygr, schema is a relation between worldbase resources, i.e.
a relationship that holds true between the items of one worldbase resource
and the items of another.  For examples, items in a "genes" resource
might each have a mapping to a subset of items in an "exons" resource.
This is achieved in worldbase by adding the mapping object itself as a worldbase
resource, and then specifying its schema to worldbase (in this example,
its schema would be a one-to-many relation between the "genes"
resource and the "exons" resource).  Adding the mapping object
as a worldbase resource, and adding its schema information, are
two separate steps::

   worldbase.Bio.Genomics.ASAP2.hg17.geneExons = geneToExons # SAVE MAPPING
   worldbase.schema.Bio.Genomics.ASAP2.hg17.geneExons = \
     metabase.OneToManyRelation(genes,exons,bindAttrs=('exons','gene'))
   worldbase.commit() # SAVE ALL PENDING DATA AND SCHEMA TO METABASE

assuming that ``genes`` and ``exons`` are the worldbase resources
that are being mapped.  This would allow a user to obtain the mapping
from worldbase and use it just as you'd expect, e.g. assuming that
``gene`` is an item from ``genes``::

   geneToExons = worldbase.Bio.Genomics.ASAP2.hg17.geneExons()
   myexons = geneToExons[gene] # GET THE SET OF EXONS FOR THIS GENE

In practice, worldbase accomplishes this by automatically setting
``geneToExon``'s ``sourceDB`` and ``targetDB`` attributes
to point to the ``genes`` and ``exons`` resources, respectively.

Since most users find it easier to remember object-oriented behavior
(e.g. "a gene has an exons attribute", rather than "there exists a
mapping between gene objects and exon objects, called geneToExons"),
worldbase provides an option to bind attributes of the mapped
resource items.  In the example above, we bound an :attr:`exons` attribute
to each item of ``genes``, which automatically performs this mapping,
e.g. we can iterate over all exons in a given gene as easily as::

   for exon in gene.exons: # gene.exons IS EQUIVALENT TO geneToExons[gene]
     # DO SOMETHING...

Note: in this usage, the user does not even need to know about the
existence of the ``geneToExons`` resource; worldbase will load it
automatically when the user attempts to access the ``gene.exons``
attribute.  It can do this because it knows the schema of the worldbase
resources!

One additional aspect of worldbase schema relations goes a bit beyond
ordinary mapping: a mapping between one object (source) and another
(target) can have *edge information* that describes this specific
relationship.  For example, the connection
between one exon and another in the alternative splicing of an mRNA
isoform, is a *splice*.  For alternative splicing analysis, it is
actually crucial to have detailed information about the splice (e.g.
what experimental evidence exists for that splice; what tissues it was
observed, in what fraction of isoforms etc.) in addition to the exons.
Therefore, worldbase allows us to save edge information also as part
of the schema, e.g. for a ``splicegraph`` representing the set of
all splices (edges) between pairs of exons (nodes), we can
store the schema as follows::

   worldbase.Bio.Genomics.ASAP2.hg17.splicegraph = splicegraph # ADD A NEW RESOURCE
   worldbase.schema.Bio.Genomics.ASAP2.hg17.splicegraph = \
     metabase.ManyToManyRelation(exons,exons,splices, # ADD ITS SCHEMA RELATIONS
                                  bindAttrs=('next','previous','exons'))
   worldbase.commit() # SAVE ALL PENDING DATA AND SCHEMA TO METABASE

This type of mapping ("edge" relations between pairs of "nodes")
is referred to in mathematics as a *graph*, and has very general
utility for many applications.  For further information on graphs in
pygr, see the tutorial or the :mod:`mapping` module reference below.

What information does worldbase schema actually store?  In practice,
the primary information stored is *attribute* relations:
i.e. for a specified resource ID, a specified attribute name
should be added to the resource object (or to items obtained
from it), which in turn maps to some specified target resource
(or items of that resource).

Although users do not need to know
how this information is saved, I will outline the methodology
as a reference for developers who want to work directly with this
internal data (skip this section otherwise).

* In a given metabase (dictionary), information for constructing a
  given resource ``id`` is stored with its resource ID as the key.
  i.e. if ``rdb`` is a metabase, ``rdb[id]`` gives
  the string to unpickle to construct the resource.  Schema information
  for that resource is stored as ``rdb['SCHEMA.'+id]``.
  
* This schema information (for a given resource) is itself
  a dictionary, whose keys are attribute names to bind to this
  resource, and whose associated values are themselves dictionaries
  specifying the rules for what to bind to this attribute and how.
  See below for further details.
  
* Attributes are added as "shadow attributes" provided by
  descriptors added to the class object for the resource or to
  its :attr:`itemClass` or :attr:`itemSliceClass` object if the
  attribute is to be bound to *items of the resource*.  Descriptors
  (also referred to in the Python documentation as "properties")
  are the major mechanism by which Python new-style classes
  (i.e. subclasses of :class:`object` in Python 2.2 and later)
  can execute code in response to a user attempt to get an
  object attribute, and are definitely preferable over writing
  :meth:`__getattr__` method code if all that's desired
  is an attribute with a specified name.  For more information
  on descriptors, see the Python Reference Manual.
  
* The basic principles of these "shadow attributes" are that
  1. they are bound to the class object, not the instance object;
  2. they are only invoked if the specified attribute name is
  missing from the instance object's :attr:`__dict__`;
  3. once invoked, they save their
  result on the instance object (in its :attr:`__dict__`)
  as the same-named attribute; 4. thus, the descriptor method
  will only be called once; thereafter the attribute will be
  obtained directly from the value cached on the instance object;
  5. the descriptor only loads its target resource(s) when the user
  attempts to read the value of the attribute.  Thus no extra
  resources are loaded until the user actually demands information
  that requires them.
  
* Currently, these shadow attributes are implemented by
  three different descriptor classes in worldbase:
  :class:`OneTimeDescriptor`, for binding attributes directly on a resource
  object (container);
   :class:`ItemDescriptor`, for binding attributes on items (or slices of
  items) obtained from a resource object (via its __getitem__ method);
  :class:`SpecialMethodDescriptor`, for binding special Python methods like
  :meth:`__invert__`.
  
* The rule information for a given attribute is itself a dictionary,
  with the following string keys governing the behavior of the shadow attribute.
  *targetID*: the worldbase resource ID of the resource that this
  attribute links to.
  *itemRule*: True if the attribute should be bound to *items*
  (and slices of items, if defined) of the source resource, rather than
  directly to the source resource object itself (if itemRule=False).
  *invert*: True if the target resource should first be inverted
  (i.e. query its reverse-mapping rather than its forward-mapping), False otherwise.
  *getEdges*: True if the attribute should query the target resource's
  :attr:`edges` mapping (i.e. the mapping provided by its :attr:`edges` attribute)
  rather than its forward mapping, False otherwise.
  *mapAttr*: if not None, use this named attribute of our source object,
  instead of the source object itself, as the key for search the target resource
  mapping.
  *targetAttr*: if not None, return this named attribute of the result of
  the search, rather than the result of the search itself.


The Standard Metabase Interface
-------------------------------

This applies both to :class:`Metabase` (representing a single metabase)
and :class:`MetabaseList` (representing a set of metabases).  They both
provide the following methods:

.. method:: Metabase.__call__(resID, debug=None, download=None, *args, **kwargs)

   Retrieve the resource specified by *resID*.

   *debug=True* will force it to raise any exception that occurs during
   the search.  By default it ignores exceptions and continues the search
   to subsequent metabases.

   *download=True* will restrict the search to downloadable resources,
   and will download and install the resource (and its dependencies) if
   it / they are not already installed locally.  If a resource is available
   locally, it will simply be used as-is.  If a resource is downloaded, it
   will also be saved to the first writeable (local) metabase for future use.

.. method:: Metabase.add_resource(resID, obj=None)

   Add *obj* as resource ID *resID* to this metabase or metabase list.
   Queues *obj* for addition to
   the metabase, and marks it with its :attr:`_persistent_id`
   attribute, whose value is just *resID*.  

   If *obj* is None, the first argument must be a dictionary of 
   resID:obj pairs, which will all be added to the metabase / list.

.. method:: Metabase.delete_resource(resID)

   Delete the resource specified by *resID* from the metabase.  For 
   a metabase list, delete it from the first writeable metabase in the list.

.. method:: Metabase.add_schema(resID, schemaObj)

   Add the schema object *schemaObj* as the schema for resource *resID*.

.. method:: Metabase.commit()

   Commit all pending resource / schema additions to the metabase.

.. method:: Metabase.rollback()

   Abandon all pending resource / schema additions since the last commit()
   or rollback().

.. method:: Metabase.clear_cache()

   Clear the metabase / list's associated cache of resources that have been
   loaded during this session.  This forces any subsequent resource requests
   to (re)load a new object.

.. method:: Metabase.dir(pattern='', matchType='p', asDict=False, download=False)

   Return a list of dictionary of all resources that match the specified
   prefix or regular expression *pattern*.

   *matchType='p'* specifies a prefix pattern.

   *matchType='r'* specifies a regular expression pattern.
 
   *asDict=True* causes the result to be returned as a dictionary of
   resID:info pairs, providing additional information about each resource.

   *download=True* will restrict the search to downloadable resources.

Metabase
--------
Interface to a single metabase.


MetabaseList
------------
Interface to a set of one or more metabases to be searched as a group.

* any resource request will be returned from the first metabase in its
  list that successfully constructs the specified resource ID.

* any resource saved to a :class:`MetabaseList` will be saved to the first
  metabase in its list that is writeable.


ResourceFinder
--------------
The core functionality of the pygr.Data module is provided by the
:class:`ResourceFinder` class, an instance of which is created at the
top-level of the module as ``pygr.Data.getResource``.  It
provides methods for adding, deleting and controlling worldbase
resources and schema.

.. function:: getResource(id, layer=None, debug=None, download=False, *args, **kwargs)

   Look up worldbase resource *id*, using the specified abstract
   resource *layer* if provided.  Searches the resouce database(s)
   for *id*, constructs it from the saved resource rule (e.g. from
   a local metabase, by unpickling the object).  Saves the
   object in its cache so that subsequent calls for the same resource
   ID will return the same object.  Applies the stored worldbase schema
   rules to it using :meth:`applySchema()`.  Marks the object with
   its :attr:`_persistent_id` attribute, whose value is just *id*.

   The *download=True* option forces worldbase to restrict the
   search to downloadable resources.  If a downloadable resource
   matching the requested ID is found, it will be downloaded to a local
   file, uncompressed, and any necessary initialization steps
   performed automatically.  The returned object will be a fully
   initialized local copy of the requested resource.

   Passing the option *debug=True* will cause it to raise any
   exception that occurs during resource loading immediately, rather
   than continuing to search its metabase list.  This is
   helpful for debugging purposes.


.. method:: getResource.addResource(id,obj,layer=None)

   Same as the top-level module function of the same name.


.. method:: getResource.addSchema(name,schemaObj,layer=None)

   Same as the top-level module function of the same name.


.. method:: getResource.dir(prefix,layer=None,asDict=False)

   Same as the top-level module function of the same name.


.. method:: getResource.deleteResource(id,layer=None)

   Same as the top-level module function of the same name.


.. method:: getResource.dumps(obj)

   Same as the top-level module function of the same name.


.. method:: getResource.list_pending()

   Same as the top-level module function of the same name.


.. method:: getResource.loads(data,cursor=None)

   Same as the top-level module function of the same name.


.. method:: getResource.newServer(name,serverClasses=None,clientHost=None,withIndex=False, host=None, port=5000, **kwargs)

   Same as the top-level module function of the same name.


.. method:: getResource.rollback()

   Same as the top-level module function of the same name.


.. method:: getResource.save_pending(layer=None)

   Same as the top-level module function ``worldbase.commit()``.


The following methods are mainly for internal use, and are unlikely to be
needed by users of worldbase.  In general, you should not use them unless
you have a very good reason to be working with the interal worldbase
methods, and really know what you are doing!
.. method:: update()

   Update ``getResource``'s list of resource databases, by parsing the environment
   variable PYGRDATAPATH and attempting to connect to the resource databases
   listed there.  Does not return anything.


.. method:: addLayer(layerName,rdb)

   Add the resource database *rdb* to the current resource database list,
   as a named layer given by the string *layerName*.  Over-writing an
   existing layer name is not allowed, for security reasons;
   the previous layer entry must first be deleted.


.. method:: getLayer(layerName)

   Get the specified resource database, by its layer name.  If *layerName*
   is None, returns the default (first) resource database in its list.


.. method:: resourceDBiter()

   Generates all the resource databases currently listed by ``getResource``.


.. method:: registerServer(locationKey,serviceDict)

   Registers the set of resources specified by *serviceDict* to the
   first metabase index in PYGRDATAPATH that will accept them.
   *serviceDict* must be a dictionary whose keys are resource IDs and
   whose associated values are pickled resource objects (encoded as strings).
   *locationKey* should be a string name chosen to represent the "location"
   where the data are stored.  This can be anything you wish, and is mainly used
   to let the user know where the data will come from.  This might be used
   in future versions of worldbase to allow preferential screening of where
   to get data from (local disk is better than NFS mounted disk, which in turn
   might be preferable over remote XMLRPC data access).


.. method:: findSchema(id)

   Returns a dictionary for the schema (if any) found for the worldbase resource
   specified by *id*.  The dictionary keys are attribute names (representing
   attributes of the specified resource or its contents that should have
   schema relations with other worldbase resources), and whose values are
   themselves dictionaries specifying the precise schema rules for constructing
   this specific attribute relation.


.. method:: schemaAttr(id,attr)

   Return the target data linked to by attribute *attr* of worldbase
   resource *id*, based on the stored worldbase schema.  The target resource
   object will be obtained by pygr.Data.getResource as usual.


.. method:: applySchema(id,obj)

   Apply the worldbase schema for resource *id* to the actual data
   object representing it (*obj*), by decorating it (and / or its itemClass
   and itemSliceClass) with properties representing its schema attributes.
   These properties are implemented by adding descriptor attributes to the
   associated class, such as :class:`OneTimeDescriptor` or :class:`ItemDescriptor`.


.. method:: saveResource(resID,obj,layer=None)

   Raw interface to actually save a specific resource to the specified
   (or default) resource database.
   DO NOT use this internal interface unless you know what you are doing!


.. method:: saveSchema(id,attr,bindingDict,layer=None)

   Save a schema attribute relation for attribute *attr* of worldbase
   resource *id*, to the specified resource database *layer* (or the default,
   first resource database in the list, if no layer specified).
   *bindingDict* must be a dictionary specifying the rules for
   binding the attribute to a worldbase resource target; see below for details.
   DO NOT use this internal interface unless you know what you are doing!


.. method:: delSchema(id,layer=None)

   Delete schema bindings for all attributes of the resource *id*, in
   the specified resource database *layer*, as well as all schema relations
   on other resources that are targeted to resource *id*.


MySQLMetabase
---------------
Implements a back-end interface to storage of a metabase in a MySQL
database table.


.. class:: MySQLMetabase(tablename, mdb, createLayer=LAYERNAME, newZone=None, **kwargs)

   Create a metabase in a MySQL database table.
   *tablename* is the table to use in the database, in the format
   "*DBNAME.TABLENAME* *dbinfo*", where *DBNAME* is the name of the
   database in the MySQL server, and *TABLENAME* is the name of
   the table in that database that you wish to use to store the
   metabase.  *dbinfo* is optional.
   If provided, it must be a whitespace separated
   list of arguments for connecting to the MySQL server, of the form
   *host* *user* *passwd*.  You can provide one, two
   or three of these optional arguments.
   If no *dbinfo* is provided, host, port, user and password info are obtained
   from your .my.cnf config file as usual for the mysql client.

   *mdb* must be the :class:`Metabase` object associated with this back-end.

   To create a new table in the MySQL database (automatically initializing its schema),
   instead of assuming that it already exists, you must provide
   the *createLayer* argument, which is saved as the layer name
   of the new metabase.  If worldbase finds that it is unable
   to connect to a MySQL database table specified in your PYGRDATAPATH
   it will print a warning message, and ignore the offending database table.
   It will NOT silently create a database table for you in this case.
   The rationale is that whereas a misspelled directory name will result in
   an IOError (thus allowing worldbase to detect a bad directory name in PYGRDATAPATH),
   there would be no easy way for worldbase to tell whether you simply mistyped the name
   of an existing MySQL table, or whether you actually wanted to create a new MySQL table.

   Example: create a new metabase, give it the layer name "leelab",
   and register it in our list of metabases::

      rdb = metabase.MySQLMetabase('pygrdata.index', mdb, createLayer='leelab')

   Note that you must provide the *createLayer* argument, in order to
   create a new metabase table.  :class:`MySQLMetabase` will not
   automatically create a new table without this argument, simply because the
   *tablename* you provided does not exist.  In that case, it will
   raise an exception to alert you to the fact that either the correct table name
   was not given, or the table does not exist.



.. method:: MySQLMetabase.find_resource(resID)

   Find resource *resID* from this metabase, or :exc:`KeyError`
   if not found.  Returns its pickle representation and docstring as a tuple.


.. method:: MySQLMetabase.__delitem__(id)

   Delete resource *id* from this metabase, or :exc:`KeyError`
   if not found.


.. method:: MySQLMetabase.__setitem__(id, obj)

   Save resource *id* to this metabase, by pickling it
   with ``self.finder.dumps(obj)``.


.. method:: MySQLMetabase.registerServer(locationKey, serviceDict)

   Saves the set of resources specified by *serviceDict* to the
   database.

   *serviceDict* must be a dictionary whose keys are resource IDs and
   whose associated values are pickled resource objects (encoded as strings).

   *locationKey* should be a string name chosen to represent the "location"
   where the data are stored.  This can be anything you wish, and is mainly used
   to let the user know where the data will come from.  This might be used
   in future versions of worldbase to allow preferential screening of where
   to get data from (local disk is better than NFS mounted disk, which in turn
   might be preferable over remote XMLRPC data access).


.. method:: MySQLMetabase.setschema(id, attr, ruleDict)

   Save schema information for attribute *attr* on resource *id*
   by pickling the *ruleDict*.


.. method:: MySQLMetabase.delschema(id, attr)

   Delete schema information for attribute *attr* on resource *id*.


.. method:: MySQLMetabase.getschema(id)

   Get schema information for resource *id*, in the form of a dictionary
   whose keys are attribute names, and whose values are the associated
   schema *ruleDict* for each bound attribute.


ShelveMetabase
----------------

Implements an interface to storage of a metabase in a Python
:mod:`shelve` (i.e. BerkeleyDB file) stored on local disk.
Provides the same interface as :class:`MySQLMetabase`, except for
no :meth:`MySQLMetabase.registerServer` method.  Note: any method call that would
save information to the database temporarily re-opens the database
file in write mode, saves the required information, and immediately
closes and re-opens
the database in read-only mode.  Thus, unless two clients try
to save information to the same file at exactly the same time,
successive writes by multiple clients will not interfere with each
other.

.. class:: ShelveMetabase(dbpath, mdb, mode='r', newZone=None, **kwargs)

   *dbpath* is the path to the directory in which the shelve
   file is found (or should be created, if none present).

   *mdb* must be the :class:`Metabase` object associated with this back-end.


XMLRPCMetabase
----------------
Implements a client interface to storage of a metabase in an XMLRPC
server.  

ResourceDBServer
----------------
Implements a server interface for storage of a metabase in
a standard Python dict, served to clients via an XMLRPC
server (use :class:`coordinator.XMLRPCServerBase` as the XMLRPC
server to serve this object).

.. class:: ResourceDBServer(layerName, readOnly=True)

   *layerName* is the layer name that this server will provide
   to worldbase clients.  *readOnly* if True, makes the server reject
   any requests to add new database rules received via XMLRPC, i.e.
   only allows :meth:`getName` and :meth:`getResource` calls via XMLRPC.
   If False, also allows calls to :meth:`registerServer` and :meth:`delResource`.


ResourcePath
------------
Used for providing the dynamically extensible worldbase namespace
that provides the normal interface for users to access worldbase resources.

.. class:: ResourcePath(mdb, base=None)

   *mdb* must be the :class:`MetabaseList` or :class:`Metabase` 
   object that you want this ResourcePath to be associated with.

   *base* specifies the ID string to use for this resourcePath.



.. method:: ResourcePath.__getattr__(attr)

   extends the resource path by one step, returning a
   :class:`ResourcePath` object representing the requested attribute.


.. method:: ResourcePath.__setattr__(attr,obj)

   saves *obj* as the specified resource ID, by calling
   :meth:`getResource.addResource`, with our layer name (if any).


.. method:: ResourcePath.__delattr__(attr)

   deletes the specified resource ID, by calling
   :meth:`getResource.deleteResource`, with our layer name (if any).


.. method:: ResourcePath.__call__(*args,**kwargs)

   Construct the specified resource ID, by calling :meth:`getResource`,
   with our layer name (if any), and the specified arguments (if any).


SchemaPath
----------
Class for top-level object representing a schema namespace.  e.g. in the worldbase
module::

   schema = SchemaPath() # CREATE ROOT OF THE schema NAMESPACE


ResourceLayer
-------------
Class for top-level object representing a pygr.Data layer.  e.g. in the worldbase
module::

   here = ResourceLayer('here') # CREATE TOP-LEVEL INTERFACE TO here LAYER


ManyToManyRelation, OneToManyRelation, ManyToOneRelation, OneToOneRelation
--------------------------------------------------------------------------
Convenience class for constructing schema relations for
a general graph mapping from a sourceDB to targetDB with edge info.

.. class:: ManyToManyRelation(sourceDB, targetDB, edgeDB=None, bindAttrs=None)

   *sourceDB*,*targetDB*, and *edgeDB* can be either
   a string resource ID, a :class:`ResourcePath` object, or
   an actual worldbase resource (automatically marked with its ID
   as the :attr:`_persistent_id` attribute).

   *bindAttrs*, if provided, must give a list of string attribute names to be
   bound, in order, to items of *sourceDB*, *targetDB*,
   and *edgeDB*, in that order.  A None value in this list simply
   means that no attribute binding will be made to the corresponding
   worldbase resource.

   Note: this class simply records the information necessary for this
   schema relation.  The information is not actually saved to the resource
   database until its :meth:`saveSchema` method is called by
   the :class:`SchemaPath` object.  In addition to saving attribute
   bindings given by *bindAttrs*, this will also create bindings
   on the mapping resource object itself (i.e. the resource whose
   schema is being set; see an example in the tutorial).  Specifically,
   it will save bindings for its :attr:`sourceDB`,:attr:`targetDB`,
   and :attr:`edgeDB` attributes to the corresponding resources
   given by the *sourceDB*,*targetDB*,
   and *edgeDB* arguments.

:class:`OneToOneRelation`, :class:`OneToManyRelation`, :class:`ManyToOneRelation`
and :class:`ManyToManyRelation` differ only in the uniqueness vs. multiplicity
of the mapping indicated.
E.g.  \textasciitilde``m1[v] --> k`` vs.
\textasciitilde``mMany[v] --> [k1,k2,...]``

DirectRelation, ItemRelation, InverseRelation
---------------------------------------------
Users are unlikely to have any reason to work directly with these
internal interfaces.  Instead, use :class:`ManyToManyRelation, OneToManyRelation, ManyToOneRelation, OneToOneRelation`
as these cover the normal schema relationships.
You should only use internal interfaces like
:class:`DirectRelation, ItemRelation, InverseRelation` if you
have a real need to do so, and really know what you are doing!
This documentation is only provided for developers directly working
on pygr internals.

:class:`DirectRelation` is a convenience class for constructing
a single schema attribute relation on a worldbase resource,
linking it to another worldbase resource.

.. class:: DirectRelation(target)

   *target* gives a reference to a worldbase resource, which will
   be the target of a bound schema attribute.  *target* can be either
   a string resource ID, a :class:`ResourcePath` object, or
   an actual worldbase resource (automatically marked with its ID
   as the :attr:`_persistent_id` attribute).


.. method:: schemaDict()

   returns a basic *ruleDict* dictionary for saving this schema binding.
   Can be over-ridden by subclasses to customize schema binding behavior.


.. method:: saveSchema(source,attr,layer=None,**ruleDict)

   Saves a schema binding for attribute *attr* on worldbase resource
   *source* to the specified metabase *layer* (or
   to the default metabase if not specified).  *ruleDict*
   if specified provides additional binding rules (which can add to or
   over-ride those returned by the :meth:`schemaDict` method).
   *source* can be either
   a string resource ID, a :class:`ResourcePath` object, or
   an actual worldbase resource (automatically marked with its ID
   as the :attr:`_persistent_id` attribute).


:class:`ItemRelation` provides a subclass of :class:`DirectRelation`
that binds to the *items* of resource *source* rather than to the
*source* object itself.

:class:`InverseRelation` provides a subclass of :class:`DirectRelation`,
that binds *source* and *target* as each other's inverse mappings.
That is, it binds an :attr:`inverseDB` attribute to each resource
that points to the other resource.  When either resource is loaded,
a special :meth:`__invert__` method will be added, that simply
loads and returns the resource pointed to by the :attr:`inverseDB`
binding.

ForeignKeyMap
-------------
Provides a mapping between two containers, assuming that items of the target
container have a foreign key attribute that gives the ID of an item in the source
container.

.. class:: ForeignKeyMap(foreignKey,sourceDB=None,targetDB=None)

   *foreignKey* must be a string attribute name for the foreign key on
   items of the *targetDB*.  Furthermore, *targetDB* must provide
   a :meth:`foreignKey` method that takes two arguments: the *foreignKey* attribute name,
   and an identifier that will be used to search its items for those whose attribute
   matches this identifier.  It must return an iterator or list of the matching items.


.. method:: __getitem__(id)

   get a list of items in *targetDB* whose attribute matches this *id*.


.. method:: __invert__()

   get an interface to the reverse mapping, i.e. mapping object that takes an
   item of *targetDB*, and returns its corresponding item from *sourceDB*,
   based on the input item's foreign key attribute value.


For example, given a container of clusters, and a container of exons (that each
have a :attr:`cluster_id` attribute), we create a mapping between them as follows::

   m = ForeignKeyMap('cluster_id',clusters,exons)
   for exon0 in m[cluster0]: # GET EXONS IN THIS CLUSTER
       do something...
   cluster1 = (~m)[exon1]  # GET CLUSTER OBJECT FOR THIS EXON


nonPortableClasses,SourceFileName
---------------------------------
The variable *pygr.Data.nonPortableClasses* specifies a list of
classes which have local data dependencies (e.g. requires reading a file
that is on your local disk),
and therefore cannot be transferred over XMLRPC to a remote client
by simple pickling / unpickling.  :meth:`pygr.Data.newServer` will
automatically cull any data that has such dependencies from the list
of resources it loads into the XMLRPC server it constructs, so that
the server will not attempt to serve data that actually will not work
on remote clients.  You can add your own classes to this list if
needed.

By default, the *pygr.Data.nonPortableClasses* list consists of simply a single
class, :class:`pygr.Data.SourceFileName`, which is a subclass of str
that marks a string as representing a path to a file.  It behaves
just like a string, but allows worldbase to be smart about checking
whether the required file actually exists and is readable before returning
a resource to the user.  If you save filenames on your own objects using
this class, worldbase will therefore be able to handle them properly for
many issues such as XMLRPC portability to remote clients.  You do this simply
as follows::

   class Foo(object):
     def __init__(self,filename):
       self.filename = SourceFileName(str(filename)) # MARK THIS A BEING A FILE NAME
       ifile = file(self.filename) # OPEN THIS FILE NOW IF YOU WANT...

